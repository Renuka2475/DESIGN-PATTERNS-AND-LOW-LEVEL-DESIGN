#DESIGN PATTERNS

##Observer Pattern

A weather station has subscribers. When data changes, notify all subscribers.
WeatherObserverable (interface) — register/remove/notify/setWeatherReadings.
WeatherObserver (interface) — update(WeatherData).
WeatherStation (class) — implements WeatherObserverable; holds List<WeatherObserver> and WeatherData; notifies observers.
WeatherData (class) — data holder: temperature, humidity.
CurrentConditionsDisplay (class) — implements WeatherObserver; reacts to updates.
ForeCastDisplay (class) — implements WeatherObserver; reacts to updates.
WeatherStationApp (class) — client bootstrap: creates WeatherStation and displays, registers observers, updates readings.

## UML Diagram:
+----------------------+          implements           +------------------+
| WeatherObserverable  |<-----------------------------|  WeatherStation  |
| <<interface>>        |                              | - users: List<>  |
| +addObserver(...)    |                              | - weatherData    |
| +removeObserver(...) |                              | +addObserver()   |
| +notifyObserver()    |                              | +removeObserver()|
| +setWeatherReadings()|                              | +notifyObserver()|
+----------------------+                              +------------------+
        ^  ^  ^
        |  |  | implements
        |  |  +--------------------------------+
        |  |                                   |
        |  |                 +------------------+      uses       +-------------+
        |  |                 | WeatherObserver  |<-----------------| WeatherData |
        |  |                 | <<interface>>    |                 | -temp       |
        |  |                 | +update(data)    |                 | -humidity   |
        |  |                 +------------------+                 +-------------+
        |  |
        |  +--> CurrentConditionsDisplay (implements WeatherObserver)
        |
        +--> ForeCastDisplay (implements WeatherObserver)

WeatherStationApp (main)
  - creates WeatherStation
  - creates displays
  - registers displays with WeatherStation
  - calls setWeatherReadings(...)


# Decorator Pattern

## The Decorator Pattern attaches additional responsibilities to an object dynamically by wrapping it inside decorator objects.
   Both the original object and the decorators implement the same interface, so the wrapped object behaves like the original but with extra features added at runtime.

   Crystal-Clear Memory Definition

   Decorator = Add features like layers around an object, each layer contributing something new, without modifying the base object or creating many subclasses.

Decorator Pattern — Story You Will Never Forget

Imagine you buy a plain pizza.
That’s your base object.

Now you tell the chef:

➡️ “Add cheese.”
He doesn’t remake the pizza —
he just wraps it with a cheese topping layer.

Then you say:

➡️ “Add olives.”
He wraps another layer on top of the pizza.

Then:

➡️ “Add mushrooms.”
Another wrapper added.

Now your final pizza is:

Mushrooms → Olives → Cheese → Plain Pizza

Each topping is a wrapper (decorator) around the pizza.

And whenever you ask:

“What’s the total cost?”

“What toppings are there?”

Your request passes through each wrapper (topping) one by one,
each adding its own cost + description.

⭐ One Line to Remember

Decorator = Add new features by wrapping an object with layers, instead of changing or creating many classes.

           +--------------------+
           |    Pizza (Interface)
           |  getDescription()
           |  getCost()
           +--------------------+
                     ▲
                     |
           +--------------------+
           |  Margherita (Concrete Pizza)
           +--------------------+
                     |
                     |
   -------------------------------------------------
   |                                               |
   v                                               v
+-------------------+               +-------------------+
| PizzaDecorator    | (Abstract)    |   Cheese          |
| - pizza: Pizza    |-------------->| +getDescription() |
|                   |               | +getCost()        |
+-------------------+               +-------------------+
                                             ▲
                                             |
                                   +-------------------+
                                   |    Olives        |
                                   | +getDescription() |
                                   | +getCost()        |
                                   +-------------------+

# Factory Pattern
Factory Pattern is used to create objects without exposing the creation logic to the client.
The client asks the factory for an object, and the factory decides which class to create.

Shape (Interface) → common contract (draw()).

Circle & Rectangle (Concrete Classes) → actual implementations.

ShapeFactory (Factory Class) → decides which Shape object to create based on input.

Client (ShapeMain) → asks factory:
"Give me a Circle" → factory returns Circle object.

                     +----------------------+
                     |       Shape          |
                     |  (interface)         |
                     |  draw()              |
                     +----------+-----------+
                                |
        -------------------------------------------------
        |                                               |
        v                                               v
+-------------------+                         +----------------------+
|      Circle       |                         |      Rectangle       |
|  implements Shape |                         |   implements Shape   |
|  draw()           |                         |      draw()          |
+-------------------+                         +----------------------+

                     +----------------------+
                     |     ShapeFactory     |
                     |----------------------|
                     |  getShape(String)    |
                     |   if "Circle"        |
                     |      return Circle   |
                     |   if "Rectangle"     |
                     |      return Rectangle|
                     +----------+-----------+
                                |
                                v
                    +----------------------+
                    |      Client          |
                    |   (ShapeMain)        |
                    | shape = factory.     |
                    |     getShape("Circle")
                    | shape.draw()         |
                    +----------------------+
